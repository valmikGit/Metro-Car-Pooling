pipeline {
    agent any

    parameters {
        booleanParam(name: 'FORCE_INFRA_UPDATE', defaultValue: false, 
                     description: 'Force infrastructure stack rebuild in K8s')
        booleanParam(name: 'DEPLOY_ALL', defaultValue: false,
                     description: 'Deploy all services regardless of changes')
    }

    environment {
        DOCKERHUB_CREDS = credentials('dockerhub-creds')
        EMAIL_IDS_TO_SEND = ""
        GIT_REPO = 'https://github.com/valmikGit/Metro-Car-Pooling.git'
        KUBECONFIG = '/var/lib/jenkins/.kube/config'
        // KUBECONFIG = '/Users/krishdave/.kube/config'
    }

    triggers {
        githubPush()  // Single webhook entry point for all services
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: "${GIT_REPO}"
            }
        }

        stage('Detect Changes') {
            steps {
                script {
                    // Get list of changed files
                    def changedFiles = sh(
                        script: "git diff --name-only HEAD~1 HEAD || echo ''",
                        returnStdout: true
                    ).trim()
                    
                    echo "Changed files:\n${changedFiles}"
                    
                    // Define service mappings (excluding contracts and registry - built separately)
                    def serviceMappings = [
                        'driver': 'driver-service',
                        'rider': 'rider-service',
                        'user': 'user-service',
                        'matching': 'matching-service',
                        'gateway': 'gateway-service',
                        'trip': 'trip-service',
                        'notification': 'notification-service',
                        'frontend': 'frontend-service'
                    ]
                    
                    // Detect which services changed
                    env.CHANGED_SERVICES = ''
                    env.INFRA_CHANGED = 'false'
                    env.CONTRACTS_CHANGED = 'false'
                    env.REGISTRY_CHANGED = 'false'
                    
                    changedFiles.split('\n').each { file ->
                        // Check for contracts changes
                        if (file.startsWith('contracts/')) {
                            env.CONTRACTS_CHANGED = 'true'
                        }
                        // Check for registry changes
                        if (file.startsWith('registry/')) {
                            env.REGISTRY_CHANGED = 'true'
                        }
                        // Check for service changes
                        serviceMappings.each { folder, jobName ->
                            if (file.startsWith("${folder}/")) {
                                if (!env.CHANGED_SERVICES.contains(jobName)) {
                                    env.CHANGED_SERVICES = env.CHANGED_SERVICES ? "${env.CHANGED_SERVICES},${jobName}" : jobName
                                }
                            }
                        }
                        // Check for infra changes
                        if (file.startsWith('infra/') || file.startsWith('k8s/')) {
                            env.INFRA_CHANGED = 'true'
                        }
                    }
                    
                    // Handle DEPLOY_ALL parameter
                    if (params.DEPLOY_ALL) {
                        env.CONTRACTS_CHANGED = 'true'
                        env.REGISTRY_CHANGED = 'true'
                        env.CHANGED_SERVICES = serviceMappings.values().join(',')
                        echo "DEPLOY_ALL enabled - deploying all services"
                    }
                    
                    echo "Contracts changed: ${env.CONTRACTS_CHANGED}"
                    echo "Registry changed: ${env.REGISTRY_CHANGED}"
                    echo "Services to deploy: ${env.CHANGED_SERVICES ?: 'None'}"
                    echo "Infrastructure changed: ${env.INFRA_CHANGED}"
                }
            }
        }

        stage('Setup Environment') {
            steps {
                echo "Cleaning Lombok from local Maven repository to force fresh download..."
                sh "rm -rf ~/.m2/repository/org/projectlombok"
            }
        }

        stage('Build Contracts') {
            when {
                expression {
                    // Only build contracts when contracts/ folder changes or DEPLOY_ALL
                    return env.CONTRACTS_CHANGED == 'true' || params.DEPLOY_ALL
                }
            }
            steps {
                echo "Building contracts module (shared dependency)..."
                sh "mvn -f contracts/pom.xml clean install -DskipTests"
                echo "Contracts installed to local Maven repository"
            }
        }

        stage('Build Registry') {
            when {
                expression {
                    return env.REGISTRY_CHANGED == 'true' || params.DEPLOY_ALL
                }
            }
            steps {
                echo "Building and pushing Registry Docker image..."
                sh "docker build -f registry/Dockerfile -t ${DOCKERHUB_CREDS_USR}/registry_microservice:latest ."
                sh "echo ${DOCKERHUB_CREDS_PSW} | docker login -u ${DOCKERHUB_CREDS_USR} --password-stdin"
                sh "docker push ${DOCKERHUB_CREDS_USR}/registry_microservice:latest"
            }
        }


        stage('Deploy Infrastructure') {
            when {
                expression {
                    return env.INFRA_CHANGED == 'true' || params.FORCE_INFRA_UPDATE || params.DEPLOY_ALL
                }
            }
            steps {
                echo "Deploying infrastructure to Kubernetes (Minikube)..."
                
                sh "kubectl config use-context minikube || echo 'Using current context'"
                
                // Apply namespace first
                sh "kubectl apply -f k8s/namespace.yaml || true"
                sh "kubectl config set-context --current --namespace=metro"
                
                // ============================================
                // PHASE 1: Install Operators
                // ============================================
                
                // Install Strimzi Kafka Operator
                echo "Installing Strimzi Kafka Operator..."
                sh """
                    kubectl create -f 'https://strimzi.io/install/latest?namespace=metro' -n metro || kubectl apply -f 'https://strimzi.io/install/latest?namespace=metro' -n metro || true
                """
                echo "Waiting for Strimzi Operator..."
                sh "kubectl wait --for=condition=Ready pod -l name=strimzi-cluster-operator -n metro --timeout=300s || echo 'Strimzi operator still starting...'"
                
                // Install Zalando Postgres Operator via Helm
                echo "Installing Zalando Postgres Operator (via Helm)..."
                sh """
                    helm repo add postgres-operator-charts https://opensource.zalando.com/postgres-operator/charts/postgres-operator/ || true
                    helm repo update
                    helm upgrade --install postgres-operator postgres-operator-charts/postgres-operator -n metro || true
                """
                echo "Waiting for Postgres Operator..."
                sh "kubectl rollout status deployment/postgres-operator -n metro --timeout=300s || echo 'Postgres operator still starting...'"
                
                // ============================================
                // PHASE 2: Deploy Infrastructure Components
                // ============================================
                
                // Deploy Redis
                echo "Deploying Redis..."
                sh "kubectl apply -f k8s/redis/redis-deployment.yml"
                sh "kubectl apply -f k8s/redis/redis-service.yml"
                sh "kubectl rollout status deployment/redis -n metro --timeout=120s || true"
                
                // Deploy Strimzi Kafka Cluster (KRaft mode - no Zookeeper)
                echo "Deploying Strimzi Kafka Cluster..."
                // NodePool must be applied first for KRaft mode
                sh "kubectl apply -f k8s/kafka/metro-kafka-nodepool.yml"
                sh "kubectl apply -f k8s/kafka/metro-kafka.yml"
                
                // Deploy Postgres cluster using Zalando Operator
                echo "Deploying Postgres Cluster..."
                sh "kubectl apply -f k8s/postgres/postgresql-zalando.yaml"
                
                // Deploy Registry (Eureka)
                echo "Deploying Registry (Eureka)..."
                sh "kubectl apply -f k8s/registry/registry-deployment.yml"
                sh "kubectl apply -f k8s/registry/registry-service.yml"
                
                // Wait for infrastructure to stabilize
                echo "Waiting for Infrastructure to stabilize..."
                sh "sleep 10"
                sh "kubectl wait --for=condition=Ready pod -l strimzi.io/name=metro-kafka-kafka -n metro --timeout=300s || echo 'Kafka not ready yet...'"
                
                // Deploy Elasticsearch
                echo "Deploying Elasticsearch..."
                sh "kubectl apply -f k8s/elasticsearch/elasticsearch-deployment.yaml"
                sh "kubectl apply -f k8s/elasticsearch/elasticsearch-service.yaml"
                
                // Deploy Logstash
                echo "Deploying Logstash..."
                sh "kubectl apply -f k8s/logging/ || true"
                
                // Deploy Ingress
                echo "Deploying Ingress..."
                sh "kubectl apply -f k8s/ingress.yaml"
                
                // Build and deploy Redis cache loader for map data
                echo "Building Redis cache loader..."
                sh """
                    cd infra
                    docker build -f redis_loader/Dockerfile -t infra-cache-loader:latest .
                    cd ..
                """
                echo "Loading cache loader image into Minikube..."
                sh "minikube image load infra-cache-loader:latest"
                
                echo "Running Redis cache loader job..."
                sh "kubectl -n metro delete job redis-loader --ignore-not-found"
                sh "kubectl apply -f k8s/redis-loader-job.yaml"
                sh "kubectl -n metro wait --for=condition=complete job/redis-loader --timeout=60s || echo 'Redis loader job timeout'"
                sh "kubectl -n metro logs job/redis-loader || true"
                
                echo "Infrastructure deployment complete"
            }
        }

        stage('Deploy Registry to K8s') {
            when {
                expression {
                    return env.REGISTRY_CHANGED == 'true' || params.DEPLOY_ALL
                }
            }
            steps {
                echo "Deploying Registry service to Kubernetes..."
                sh "kubectl config use-context minikube || echo 'Using current context'"
                sh "kubectl apply -f k8s/registry/"
                sh "kubectl rollout status deployment/registry -n metro --timeout=180s || true"
                echo "Registry service deployed"
            }
        }



        stage('Trigger Service Pipelines') {
            when {
                expression {
                    return env.CHANGED_SERVICES?.trim()
                }
            }
            steps {
                script {
                    def services = env.CHANGED_SERVICES.split(',')
                    def parallelBuilds = [:]
                    
                    services.each { service ->
                        def trimmedService = service.trim()
                        if (trimmedService) {
                            parallelBuilds[trimmedService] = {
                                echo "Triggering ${trimmedService}..."
                                build job: trimmedService,
                                      parameters: [
                                          string(name: 'GIT_COMMIT', value: env.GIT_COMMIT),
                                          string(name: 'TRIGGERED_BY', value: 'master-orchestrator')
                                      ],
                                      wait: true,
                                      propagate: true
                            }
                        }
                    }
                    
                    if (parallelBuilds.size() > 0) {
                        parallel parallelBuilds
                    } else {
                        echo "No services to trigger"
                    }
                }
            }
        }

        stage('No Changes Detected') {
            when {
                expression {
                    return !env.CHANGED_SERVICES?.trim() && env.INFRA_CHANGED == 'false' && 
                           env.CONTRACTS_CHANGED == 'false' && env.REGISTRY_CHANGED == 'false' &&
                           !params.FORCE_INFRA_UPDATE && !params.DEPLOY_ALL
                }
            }
            steps {
                echo "No relevant changes detected. Skipping build."
            }
        }

        stage('Summary') {
            steps {
                script {
                    def summary = """
                    =============================================
                    BUILD SUMMARY
                    =============================================
                    Commit: ${env.GIT_COMMIT ?: 'N/A'}
                    Contracts Built: ${env.CONTRACTS_CHANGED == 'true' || env.CHANGED_SERVICES?.trim() || params.DEPLOY_ALL}
                    Registry Built: ${env.REGISTRY_CHANGED == 'true' || params.DEPLOY_ALL}
                    Infrastructure Updated: ${env.INFRA_CHANGED == 'true' || params.FORCE_INFRA_UPDATE}
                    Services Deployed: ${env.CHANGED_SERVICES ?: 'None'}
                    Deploy All: ${params.DEPLOY_ALL}
                    Force Infra: ${params.FORCE_INFRA_UPDATE}
                    =============================================
                    """
                    echo summary
                }
            }
        }
    }

    post {
        success {
            echo "Master orchestrator completed successfully"
            // emailext(
            //     to: "${EMAIL_IDS_TO_SEND}",
            //     subject: "SUCCESS: Master Pipeline #${env.BUILD_NUMBER}",
            //     body: """
            //     <h2>Build Successful!</h2>
            //     <p><b>Job:</b> ${env.JOB_NAME}</p>
            //     <p><b>Build Number:</b> ${env.BUILD_NUMBER}</p>
            //     <p><b>Services Deployed:</b> ${env.CHANGED_SERVICES ?: 'None'}</p>
            //     <p><b>Infrastructure Updated:</b> ${env.INFRA_CHANGED == 'true' || params.FORCE_INFRA_UPDATE}</p>
            //     <p><b>URL:</b> <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></p>
            //     """,
            //     mimeType: 'text/html'
            // )
        }
        failure {
            echo "Master orchestrator failed"
            // emailext(
            //     to: "${EMAIL_IDS_TO_SEND}",
            //     subject: "FAILURE: Master Pipeline #${env.BUILD_NUMBER}",
            //     body: """
            //     <h2>Build Failed!</h2>
            //     <p><b>Job:</b> ${env.JOB_NAME}</p>
            //     <p><b>Build Number:</b> ${env.BUILD_NUMBER}</p>
            //     <p><b>Services Attempted:</b> ${env.CHANGED_SERVICES ?: 'None'}</p>
            //     <p><b>URL:</b> <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></p>
            //     <p>Please check the console output for details.</p>
            //     """,
            //     mimeType: 'text/html'
            // )
        }
        cleanup {
            cleanWs()
        }
    }
}
